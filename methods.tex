\section{Methods \& Strategies}
\label{sec-methods}

Archetype development can be a daunting task on its own. For this reason 
many fuel cycle simulators choose to supply only a limitted corral of 
prebuilt archetypes. This places the responsibility of creating an maintaing 
the archetypes with the authors of the simulator.

When only prebuilt archetypes are available then this suite defines the scope 
of all possible fuel cycles that a user can model. If the scope is not broad 
enough for the needs of a user then the simulator developer  must expand the 
scope or lose the user.  This creates a bottleneck because the number of users 
may increase while the time of the simulation developer remains constant.

\Cyclus avoids such bottlenecks by empowerring users to create and maintain 
their own archetypes independent of the development timeline of the \cyclus 
kernel. However this modularity comes with its own costs. Being able to 
plugin user-created archetypes implies a proggraming contract (API) where 
the archetype conforms to certain well-defined expectations. This is an 
additional burden to nascent and experianced archetype developers that 
does not effect the underlying behavior or physics. Rather, a large portion 
of archetype code exists to satisfy the \cyclus API.

Mitigating the difficiulties in writing archetypes has been a major effort 
for \cyclus. This includes the all of the difficulties in interfacting with 
\cyclus itself and, to the extent possible, providing tools that make it 
easier to implement the physics and behavior desired. Here, we illustrate 
a vareity of strategies that are used by \cyclus ease development. They are, 

\begin{itemize}
    \item \textbf{Preprocessing \& Code Generation:}  By automatically 
        inspecting and creating portions of archetypes, the overhead
        of adhering to the \cyclus inteface is removed. This also 
        adds limitied refelection to C++, as needed, which is important 
        for archetypes that wish to know about themselves.

    \item \textbf{Type System Abstraction:} The \Cyclus type system 
        provides a common basis for archetypes to store and retrieve 
        complex types in the database. It alliviates the need for archetype
        developers to invent and implement custom persistenece solutions.

    \item \textbf{Validation:} Archetypes use XML schema to validate that 
        the prototypes that are generated from them are created correctly.
        This ensures the user of an archetype are using it correctly.

    \item \textbf{Metadata Annotations:} Archetypes have a standard place to 
        store and reteive both pre-defined and arbitrary metadata about themselves.
        This allows for archetype developers to communicate relevant information
        to tools outside of \cyclus (such as a visulaization tool) without
        losing any information in the process of being an archetype.

    \item \textbf{Package System:} \Cyclus has a packaging system for archetypes and 
        libraries of archetypes. This means that all archetype developers can 
        uniquely specify their own archetypes without the fear of overlapping 
        names.  For example, two developers could each have a \texttt{Reactor}
        archetype, but they would live in different packages and be 
        disabiquated.

    \item \textbf{Removal of Markets:} In moving to an agent-based methodology, 
        the mechanism for communication between agents is not an agent itself.
        Thus in \cyclus, market resolution was moved to be solely in the purview 
        of kernel. In order to transfer resoruces, agents must now comunicate 
        in a well-defined way. This makes it easier to develop an archetype than 
        the situation where markets specify how they wish to be communicated with 
        and the archetype has to adapt. 

\end{itemize}

Though the above are with respect to \cyclus, these mechanisms are 
transferable to any agent-based modeling framework that needs to have modular agent 
archetypes. The following subsections present greater detail about the 
strategies themselves.

\subsection{Preprocessing \& Code Generation}

Every \cyclus archetype is required to implement the member functions 
seen in Listing \ref{req-api} and optionally may implement those seen in 
Listing \ref{opt-api}. Due to the way object orietation works in 
C++ and how \cyclus stores state, these member functions must be implemented directly
on the archetype itself. The implementation that archetypes inherit 
from the \code{Agent} class is not sufficient. 

\begin{lstlisting}[caption={Required Archetype API}, label=req-api]
void InfileToDb(InfileTree* tree, DbInit di);
void InitFrom(cyclus::QueryableBackend*);
void InitInv(cyclus::Inventories& invs);
cyclus::Inventories SnapshotInv();
void Snapshot(cyclus::Agent*);
std::string schema();
Json::Value annotations();
cyclus::Agent* Clone();
void InitFrom(cyclus::Agent*);
\end{lstlisting}

\begin{lstlisting}[caption={Optional Archetype API}, label=opt-api]
void Build(cyclus::Agent* parent);
void EnterNotify();
void BuildNotify(cyclus::Agent* child);
void Decommission(cyclus::Agent* child);
\end{lstlisting}

This is because archetypes store state as public or private member variables
directly on the class.  For example, a \code{Reactor} archetype class
could have a burnup declared as `\code{double burnup};'. Not every agent has 
a burnup, say for example \code{Enrichment}, and so the \code{burnup} member 
should not be part of \code{Agent}. Furthermore, archetypes are modularly 
defined. Thus there is no way for \cyclus to know all possible field names 
for all possible archetypes for all time.  \Cyclus can only react to how 
archetypes happen to have been written. In a dynamic language, the \code{Agent}
superclass would still be able to to \emph{inspect} instances of its subclasses
to discover field names at runtime. Such introspections is called \emph{reflection}. 
This would allow \code{Agent} to hold a single, generic implementation of each of the
member functions in Listing \ref{req-api}, preventing archetype developers from 
having to impplement them manually.

However, C++ lacks reflection. Neither \code{Agent} nor archetypes are allowed
to dynamically discover what their member variable names are at runtime.  This 
implies that the archetype developer must explicitly code in the approriate variable
names in the correct way for each of the nine required functions.  For instance, 
the \code{Reactor} class must explicitly save the \code{burnup} member in the 
\code{Snapshot()} function if \code{burnup} is to be saved to the database.
Nothing comes along for free and minor typos can cause large breakages. 

Since implementing this part of the archtype API is both highly error-prone and 
very regular it is ripe for automatic code generation. This would replace the 
tedious task of writing the required member functions with software that will 
insert such member functions into an otherwise fully developed archetype. 

The code generation strategy has some limitations. The first is that it must be 
performed prior to compiliation and generated valid C++. The second is that the 
code generator must be provided with enough information about the archetype in 
order to accurately create the function implmentations. Third and finally, it 
is highly desirable to keep archetypes in valid C++. Templating languages 
such as Jinja \citeme or any other variety of custom solutions would allow for 
expressive code generation. However, such template languges would be yet another 
tool for the archetype developer to learn, running counter to the goal of 
simplifying development.

The limitiations above are all elegantly addressed through the use of a 
\cyclus-aware preprocessor. The first stage of C/C++ compilation is the 
C Prepocessor or \code{cpp} \citeme. This tool is responsible for expanading 
\code{#include}s and implemented other \code{#} directives. It is executed
prior to any other stage of compilation (lexing, parsing, tokenizing, \emph{etc.}).
Importantly, the \code{#pragma} directive is skipped by \code{cpp} if it is not 
recognized and the directive is retianed its output. It is purposefully a 
hook for other preprocessors to use and implement their own code generation.
If an alternative preprocessor only uses \code{#pragma}s as its interface, 
the developer will be able to write in pure C++ and reap the benefits
of an extra code generation step. 

Any code generator, however, must be supplied with sufficient information about
where and how to create the code. These tasks may also be accomplished through 
the use of pragmas. To handle a suite of such utilities a custom preproccessor
is needed.

Certain pragmas may be used to parse only the needed information 
about an archetype, rather than parsing the entire class. For archetypes, the 
member variables that are saved and loaded from its instances are the most important.
This is because it is these variables that the fully describe the state of an agent 
at all point in the simulation. Thus they are known as \emph{state variables}. 
To generate the appropriate I/O routines for an archetype the names and C++ types 
of all state variables must be known at a minimum. Hence this process is 
called \emph{state accumulation}. 

Still other pragmas may 
signal where to insert automatically generated code. The tedious 
part of the \code{cyclus::Agent} interface should be created. In specific, 
the member functions given in Listing \ref{req-api} should be inserted automatically
so that archetype developer need not write them.

The \cyclus preprocessor, called \cycpp, handles all of the cyclus code generation
and state accumulation. This tool looks only for directives that begin with 
with \code{#pragma cyclus} so as to uniquely distingish it from other preprocessors.
There are three main passes that \cycpp uses on archetype code:
\begin{enumerate}
    \item Normalization of the source via the standard preprocessor \code{cpp}, 
    \item Accumulation of state and other agent annotations from normalized code, 
    \item Code generation into original source.
\end{enumerate}
It is important to note that any preprocessor that adds reflection must have at
minimum two passes: discovery of what exists (state accumulation) and adding this
information back to the class (code generation). Single-pass preprocessors such 
as the standard \code{cpp} utility are not suffient to add reflection because they 
cannot guarentee that all relevant class information has been seen by the point 
where code generation must happen. Thus \cycpp has this two passes and an additional 
initial pass to make state accumulation easier. Further passes could be added which 
implement reflection onto the generated code itself but this is often uncessary. 
In \cyclus further passes would be excessive since only portions of the 
\code{cyclus::Agent} interface are generated and these are known ahead of time.

\cyclus-specific pragmas are broken up into two catergories depending on whether 
they are most relevant to the state accumulation or to code generation. They 
are denoted as \emph{annotation directives} and \emph{code generation directives}
respectively.

The \cycpp annotation interface has two main directives:
\begin{itemize}
    \item \code{#pragma cyclus var <dict>} - state variable annotation
    \item \code{#pragma cyclus note <dict>} - agent annotation or note
\end{itemize}
The state variable annotation is used on the line immeadiately above an archetype
member variable to declare it as being a state variable. The note directive is used
anywhere in an archetype class declaration and applies to the archetype itself.
Both of these have a \code{<dict>} argument that is a Python dictionary. This 
holds metadata about the state variable or the archetype. For example, a \code{flux}
state variable may be declared as in Listing \ref{flux-pragma}.

\begin{lstlisting}[caption={Flux State Variable Annotation}, label=flux-pragma]
#pragma cyclus var {"default": 42.0, "units": "n/cm2/s"}
double flux;
\end{lstlisting}

The code generation interface in it is simplest form occurs via the \cyclus 
prime directive, or merley \code{#pragma cyclus}.  This expression will 
generate the entire archetype interface and insert it in place of the pragma.
More fine-grained code generation may be used by passing additional arguments.
The signature for such targeted code generation may be seen in Listing \ref{targ-cg}.
The first argumnet is one of \code{decl}, \code{def}, or \code{impl} representing 
interface declarations, definitions (the declaration and the implementation together), 
or implementions (just the body without the declaration) of the archetype member
functions. Lacking any further arguments, this will produce the desired code for 
all of member functions in Listing \ref{req-api}.  Optionally, a member function 
name in all lowercase (ie \code{inittodb} rather than \code{InitToDb}) may 
be supplied to generate code for the given function alone.  Lastly, in 
cases where \cycpp cannot figure out the archetype to apply the code generation for
such as an in an implementation file (\code{*.cc} or \code{*.cpp}), the agent
class name may be provided as a final parameter.

\begin{lstlisting}[caption={Targeted Code Generation Directive Signatures}, 
                   label=targ-cg]
#pragma cyclus <decl|def|impl> [<func> [<agent>]]
\end{lstlisting}

When the annotation and code generation directives are combined and expanded with 
\cycpp, simple agent become simple to write and complex agents confine their 
complexity to the physics and economics that they seek to implement. The base \cyclus
infrastructure largely is removed from the concern of the archetype developer.
For example, a simple reactor model may be completely implemented as seen in 
Listing \ref{rx-eg}. The barrier to creating new archetypes is much lower than 
compared to the hundreds of lines that this would take without \cycpp.

\begin{lstlisting}[caption={Simple Reactor Archetype}, label=rx-eg]
class Reactor : public cyclus::Facility {
 public:
  Reactor(cyclus::Context* ctx) {};
  virtual ~Reactor() {};

  #pragma cyclus

 private:
  #pragma cyclus var {'default': 4e14, 'units': 'n/cm2/2'}
  double flux;

  #pragma cyclus var {'default': 1000, 'units': 'MWe'}
  float power;

  #pragma cyclus var {'doc': 'Are we operating?'}
  bool shutdown;
};
\end{lstlisting}

\subsection{Type System Abstraction}

\textbf{Anthony}

\subsection{Validation}

\textbf{Katy}

\subsection{Metadata Annotations}

\textbf{Radio}

\subsection{Package System}

\textbf{Robert C.}

\subsection{Removal of Markets}

\textbf{Matt}
