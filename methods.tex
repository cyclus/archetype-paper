\section{Methods \& Strategies}
\label{sec-methods}

Archetype development can be a daunting task on its own. For this reason 
many fuel cycle simulators choose to supply only a limitted corral of 
prebuilt archetypes. This places the responsibility of creating an maintaing 
the archetypes with the authors of the simulator.

When only prebuilt archetypes are available then this suite defines the scope 
of all possible fuel cycles that a user can model. If the scope is not broad 
enough for the needs of a user then the simulator developer  must expand the 
scope or lose the user.  This creates a bottleneck because the number of users 
may increase while the time of the simulation developer remains constant.

\Cyclus avoids such bottlenecks by empowerring users to create and maintain 
their own archetypes independent of the development timeline of the \cyclus 
kernel. However this modularity comes with its own costs. Being able to 
plugin user-created archetypes implies a proggraming contract (API) where 
the archetype conforms to certain well-defined expectations. This is an 
additional burden to nascent and experianced archetype developers that 
does not effect the underlying behavior or physics. Rather, a large portion 
of archetype code exists to satisfy the \cyclus API.

Mitigating the difficiulties in writing archetypes has been a major effort 
for \cyclus. This includes the all of the difficulties in interfacting with 
\cyclus itself and, to the extent possible, providing tools that make it 
easier to implement the physics and behavior desired. Here, we illustrate 
a vareity of strategies that are used by \cyclus ease development. They are, 

\begin{itemize}
    \item \textbf{Preprocessing \& Code Generation:}  By automatically 
        inspecting and creating portions of archetypes, the overhead
        of adhering to the \cyclus inteface is removed. This also 
        adds limitied refelection to C++, as needed, which is important 
        for archetypes that wish to know about themselves.

    \item \textbf{Type System Abstraction:} The \Cyclus type system 
        provides a common basis for archetypes to store and retrieve 
        complex types in the database. It alliviates the need for archetype
        developers to invent and implement custom persistenece solutions.

    \item \textbf{Validation:} Archetypes use XML schema to validate that 
        the prototypes that are generated from them are created correctly.
        This ensures the user of an archetype are using it correctly.

    \item \textbf{Metadata Annotations:} Archetypes have a standard place to 
        store and reteive both pre-defined and arbitrary metadata about themselves.
        This allows for archetype developers to communicate relevant information
        to tools outside of \cyclus (such as a visulaization tool) without
        losing any information in the process of being an archetype.

    \item \textbf{Package System:} \Cyclus has a packaging system for archetypes and 
        libraries of archetypes. This means that all archetype developers can 
        uniquely specify their own archetypes without the fear of overlapping 
        names.  For example, two developers could each have a \texttt{Reactor}
        archetype, but they would live in different packages and be 
        disabiquated.

    \item \textbf{Removal of Markets:} In moving to an agent-based methodology, 
        the mechanism for communication between agents is not an agent itself.
        Thus in \cyclus, market resolution was moved to be solely in the purview 
        of kernel. In order to transfer resoruces, agents must now comunicate 
        in a well-defined way. This makes it easier to develop an archetype than 
        the situation where markets specify how they wish to be communicated with 
        and the archetype has to adapt. 

\end{itemize}

Though the above are with respect to \cyclus, these mechanisms are 
transferable to any agent-based modeling framework that needs to have modular agent 
archetypes.  The following subsections present greater detail about the 
strategies themselves.

\subsection{Preprocessing \& Code Generation}

\textbf{Anthony}

\subsection{Type System Abstraction}

\textbf{Anthony}

\subsection{Validation}

\textbf{Katy}

\subsection{Metadata Annotations}

\textbf{Radio}

\subsection{Package System}

\textbf{Robert C.}

\subsection{Removal of Markets}

\textbf{Matt}
