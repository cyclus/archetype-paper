\section{Conclusions}
\label{sec-conc}

Writing archetypes can be a daunting task because reasonably accurate models 
require knowledge of physics, economics, and computer science to solve a single nuclear engineering 
problem.  Unlike other spheres of nuclear engineering, decoupling these domains from
one another is often not possible without significant simplification. \cyclus is 
no exception to this and is designed to allow for complete fidelity throughout 
all aspects of the simulation. \comment{The advantage of the \cyclus design is that it enables full modeling fidelity without requiring that archetype developers actively address every class of 
problem every time they pursue a new archetype.}

\Cyclus succeeds in simplifying archetype development by identifying a category 
of computer science \& software development problems that are addressed 
algorithmically. This moves effort away from humans, who are pursing physics and
economics, and onto computers. This automation happens by default for as much of
an archetype as possible. In this case the archetype developer writes approximately
10 times less software, excluding physics and resource exchange routines, than
they would manually. Additionally, the automation may be cherry-picked piece by piece,
down to nothing if desired. The \cyclus system of archetype development nimbly 
adapts to the needs of the archetype by allowing the developer to select the 
level of computer science that they explicitly use.  

The \cyclus system makes for better fuel cycle simulations by creating better 
archetypes.  This is a consequence of two features of the preprocessor. First, 
\cyclus encourages developers to write the archetype
that they intended to implement, and second, the archetypes are automatically
validated.

State variables are easy to create. When a software feature has a high cost to use,
developers will minimize the number of times that they invoke it. This can 
sometimes lead to sacrificing model fidelity in an effort to author more concise
code, which is its own virtue. However, the long-term completeness of an archetype
with respect to its physics calculations should not be based, even in part, on the
short-term impetus to have a minimum-viable product. By dramatically reducing the 
length of time it takes to implement a state variable, archetype developers implement
more state variables and thus more precisely implement their models.

Furthermore, automatically generating archetype code removes typographic errors and 
\cyclus interface misuse, avoiding potential problems in archetype development. The 
generated code derives its validity from \cycpp, which itself is extensively 
tested. Any errors accidentally introduced by \cycpp would be endemic to all archetypes, 
but a fix to \cycpp would be the corresponding panacea. Archetypes are thus 
better in \cyclus due to \cycpp.

The preprocessor \sout{, however,} generates schema for archetypes. This provides a mechanism 
for validating user input automatically.  Without user input validation, the archetype 
developer has no guarantee that the user has entered a meaningful or physically possible 
value (e.g. negative fluxes). Rather than approaching this problem in an \emph{ad hoc}
manner, the \cyclus interface demands that this go through \acrlong{RNG}.  The overhead 
of this requirement is mitigated since the archetype developer obtains the schema
for free. This assures a high level of quality in using archetypes as well as 
developing them.

The strategies detailed and implemented in this paper combine to nearly completely 
remove the overhead of writing archetypes. By enabling more expressibility and greater
modifiability, developers and simulators are able to more easily experiment.  
Alternative fuel cycle representations may be explored quantitatively at an
unparalleled rate.

That said, archetype development tools and approaches are not without further 
potential refinements. Continued improvement to \cycpp remains possible. As more 
archetypes are developed, common usage patterns will emerge. Codifying and 
auto-generating these patterns is a rich area of exploration. The authors anticipate 
that inventory and resource exchange patterns will be among the first targeted.
This would likely take the form of new filters in pass three.

\sout{Furthermore, } The fundamentals of the \cyclus type system will be used in perpetuity, as enabled by the extensibility of the type system.  More types will continue to 
be added as needed by the archetype developers.  \sout{However,} It is also possible to 
make the type system dynamic and allow for custom types to be implemented at run time.
This could be a boon to archetype developers seeking to create a wide variety of custom
tables.

The preprocessor could also improve the generated code. \Cyclus reserves the right
to add additional metadata keys and associated meanings.  For example, a \code{'range'}
key could specify the acceptable range for a state variable. This could in turn 
provide better validation by adding bounds checks beyond the what is performed
by \gls{RNG}. A similar strategy could be followed for categorical variables whereby
set membership would be verified. The code that is generated for future keys 
depends largely on the meaning ascribed to those keys. \sout{However, } There is no limit 
to the richness of available metadata.

In summary, archetype development is now significantly easier. This is due in large
part to the advent of the \cyclus preprocessor. While \cycpp itself is the fruit of
a large computer science and software development effort, it is used here 
primarily to improve fuel cycle simulations. As a platform for archetype
development, \cyclus provides solid ground and is simultaneously nimble enough
to allow for future growth. Independent of \cyclus, the strategies and methods that
\cyclus implements for archetype developers are translatable to any agent-based 
fuel cycle simulator.  Some aspects, such as the type system,  may even be exportable 
to general simulation science. \sout{ though they are needed here due to the complexity of 
fuel cycle simulation.}

