\section{Implementation}
\label{sec-impl}

In \S \ref{sec-methods}, the strategies and interfaces that \Cyclus uses to 
simplify archetype development were presented. These represent notions about
the amount of information and prior knowledge that the archetype developer 
must have in order to write archetypes.  If a particular strategy 
decreases the knowledge required by archetype developers then it is considered
easier and beneficial to implement.  

However, methods that are more intuitive for new users to understand are often
proportionately more difficult to implement. For example, it is one thing to 
learn to play the game \emph{tic-tac-toe}, or even master it; it is quite another
thing to design the game \emph{tic-tac-toe} in the first place.  
A sublime interface belies 
herculean effort. This section describes the infrastructure that holds up 
current \cyclus archetype development.  This is relevant to other fuel 
cycle simulators that wish to adopt the same strategies that \cyclus 
implements. In particular, the implementation of the \cyclus preprocessor, 
the type system, input file validation, and metadata annotations will all 
be covered here.

\subsection{The \Cyclus Preprocessor}

The \cyclus preprocessor, \cycpp, is responsible for all metadata collection and 
code generation for archetypes. It is implemented as a small Python utility 
currently less than 2000 lines in a single file.  It has no dependencies other 
than the Python standard library \citeme. It is thus light-weight enough to move around 
between code projects, if needed. For the scale of its responsibility, \cycpp
is extremely efficient. 

The preprocessor implements the three passes detailed in \S\ref{subsec-ppgc}:
normalization via standard \code{cpp}, state variable annotation accumulation, and code 
generation. The \cycpp tool must be run on all C++ header and source files that
contain archetype code and the \code{#pragma cyclus} directives. Running \cycpp
on files without such directives does no harm and will result in exactly the 
original file. The first \cycpp
pass, running the C preprocessor over these files, is a trivial subprocess 
spawn. The only potential trouble spots here are ensuring that \cycpp sees the
same include, macro definitions, and macro un-definitions that actual compilation 
of the source code will have.

The second pass, state accumulation, represents half of the work that \cycpp performs.
The results from pass 1 is fed into this pass and scoured for 
potentially relevant information about the archetypes present in the file. 
Thus, state accumulation 
may be thought of as a traditional parser which transforms tokens (line of the 
C++ file) into a more meaningful in-memory data structure. As a parser, pass 2 
may be implemented as a \emph{state machine} \cite{mertz2003text,wagner2006modeling}.

Pass 2 is represented in \cycpp by the \code{StateAccumulator} class.  This is a
state machine which takes lines output from the C preprocessor and compares them 
against a series of \emph{filters}.  If a line matches the expected structure 
for a filter, then the filter executes a \emph{transformation} function on the 
line and no further filters are executed. If the line does not match any 
filters, then the line is allowed to pass through the \code{StateAccumulator}.  
The filter-transformation sequence can be thought of in analogy to a sphere of 
a given radius (a line of code) attempting to pass through concentric windows 
(the filters) of decreasing aperture. This first window where the sphere stops 
represents the transformation that is executed.  This sphere is allowed to move 
through the system without being stopped. This analogy may be seen in Figure 
\ref{filter-analogy}.  

\begin{figure}[htbc]
\label{filter-analogy}
\centering
\includegraphics[width=0.8\textwidth]{filter-analogy.eps}
\caption{The \code{StateAccumulator} class passes lines of C++ code through 
a series of filters, each of which may transform the information heretofore gathered
by previous filters. 
This may be thought of analogous to a spheres of various radii rolling through 
concentric windows.  The spheres, or lines of code, stop rolling when they hit a  
window, or filter. This triggers the execution of the transformation function of just 
that filter and that filter alone.}
\end{figure}

The filters implemented for pass 2 of \cycpp are described in Table \ref{pass2-filters}, 
in order of decreasing precedence. The most important of these filters implement 
the \code{#pragma cyclus} directives that the archetype uses to communicate
with the preprocessor.  The pragma filters tend to modify attributes of
the \code{StateAccumulator} such as the \code{context}, the \code{execns} 
(or \emph{execution namespace}), the \code{aliases} set, and the \code{namespaces}. 
These represent the classes, types, aliases, and other information that defines
the scope of the C++ code that has been seen thus far. Such information is necessary 
for accurately representing archetypes and their state variables. 

Most pass 2 filters that do not implement a preprocessor directive instead
aggregate information about the available types. The \code{VarDeclarationFilter} has
the important job of determining the C++ type of state variables from the 
member variable declaration on the archetype class. However, the C++ type system 
is a complex beast that allows for a number of programmer modifications prior 
to the type declarations.  Types may be aliased to any number of alternative 
names, template types are white-space insensitive, scoping rules apply 
to new type names, and other issues must be resolved to accurately and uniquely 
represent a C++ type.  This requires that \cycpp reimplement relevant type handling
simply to get the spellings correct. 
Thus the \code{StateAccumulator} accumulator acts as its own type system and is 
able to return the canonical form of any type it knows about at all points during 
pass 2 of \cycpp.

\begin{table}
\label{pass2-filters}
\caption{\cyclus Preprocessor Pass 2 Filters, higher order filters have 
         lower execution precedence.}
\begin{tabular}[htb]{|p{0.05\linewidth}|p{0.33\linewidth}|p{0.6\linewidth}|}
\hline
\textbf{order} & \textbf{filter} & \textbf{description} \\
\hline
1  & \code{ClassAndSuperclassFilter} & Accumulates the class name from a class 
                                       declaration. Also stores the names of the 
                                       superclasses from the declaration.\\ 
\hline
2  & \code{AccessFilter} & Sets the current access control level, either 
                           \code{public}, \code{private}, or \code{protected}.\\
\hline
3  & \code{ExecFilter} & Implements the \code{#pragma cyclus exec <code>} directive
                         that allows for the execution of arbitrary Python code.
                         The results of this code are added the context that 
                         evaluated other \cycpp directives.\\ 
\hline
4  & \code{UsingNamespaceFilter} & Adds and removes a namespace from the 
                                   current scope via the C++ \code{using namespace}
                                   statement.\\ 
\hline
5  & \code{NamespaceAliasFilter} & Implements namespace aliasing in the current 
                                   scope.\\ 
\hline
6  & \code{NamespaceFilter} & Sets and reverts a new namespace scope.\\ 
\hline
7  & \code{TypedefFilter} & Adds a type alias to the current scope via the 
                            C++ \code{typedef} statement.\\ 
\hline
8  & \code{UsingFilter} & Removes scope from a type by adding an alias in the 
                          current scope via the C++ \code{using} statement.\\ 
\hline
9  & \code{LinemarkerFilter} & Interprets \code{cpp} linemarker directives in order
                               to produce more useful debugging information in 
                               \cycpp.\\ 
\hline
10 & \code{NoteDecorationFilter} & Handles the \cycpp \code{#pragma cyclus note <dict>}
                                   directive by evaluating the contents of 
                                   \code{<dict>} and adding them to the archetype 
                                   annotations.\\ 
\hline
11 & \code{VarDecorationFilter} & Implements the \cycpp \code{#pragma cyclus var <dict>}
                                  directive for state variable annotations. The 
                                  \code{<dict>} is evaluated in the current 
                                  context and queued up to be applied to the 
                                  next state variable declaration.\\ 
\hline
12 & \code{VarDeclarationFilter} & State variable declaration. Applies the results 
                                   of the immediately prior \code{VarDecorationFilter}
                                   as the state variable annotations. Furthermore, 
                                   this filter parses out the name of the 
                                   state variable, its index with respect to other 
                                   state variables on this class, and resolves its
                                   C++ type into an unambiguous form.\\ 
\hline
13 & \code{PragmaCyclusErrorFilter} & Throws errors if \code{#pragma cyclus} 
                                      directive is incorrectly implemented.
                                      This moves errors from happening at compile 
                                      or run time to \cycpp.\\
\hline
\end{tabular}
\end{table}

In \cycpp, the only relevant type information is the name.  The concrete size in bits
of a type and the operations that are available for that type are not directly 
relevant. This is because the primary purpose of the type of a state variable is
to be able to fill in the relevant value in the pass 3 code generation. Further 
reflection is not used by \cycpp itself. Thus the canonical spelling of the type 
name is the only relevant piece of information.  

The canonical form of a type has the following spelling rules:
\begin{itemize}
    \item Primitive types (\code{int}, \code{double}, \code{std::string}, etc.) 
          and classes (\code{cyclus::Blob}, etc.) are spelled with strings 
          of the names.
    \item Template types (\code{std::vector}, \code{std::map}, etc.) are spelled 
          with lists of length of the number of template parameters plus one.
          The first element of the list is a string that represents the 
          template type (e.g. \code{std::pair}). The remaining elements of 
          the list represent the template parameter types, in order, and may 
          be either strings or lists.  For example, the type 
          \code{std::map<int, std::vector<double>>} would have the canonical form 
          of \code{['std::map', 'int' ['vector', 'double']]}.
    \item All namespaces must be included in the type name.
    \item Pointer and reference types are not allowed because these may not be 
          represented in the database.
\end{itemize}
When taken together, these rules create an accurate and language-independent
mechanism for spelling C++ types, including templates. The preprocessor is aware
of the following types which may be present in a \cyclus database in various 
combinations:
\begin{itemize}
    \item \textbf{Primitives:} \code{bool}, \code{int}, \code{float}, \code{double}, 
                               \code{std::string}
    \item \textbf{Known Classes:} \code{cyclus::Blob}, \code{boost::uuids::uuid}, 
                                  \code{cyclus::toolkit::ResourceBuff}
    \item \textbf{Templates:} \code{std::vector}, \code{std::set}, \code{std::list}, 
                              \code{std::pair}, \code{std::map}
\end{itemize}

Resolving a canonical type name is necessarily a recursive process.
This is because aliases may point to other aliases --- not just primitive type names.
Thus to resolve an alias, one must walk through an arbitrarily deep graph of aliases 
to find the associated primitive.  For example, given that \code{myfloat} points 
to \code{float} (the primitive) and \code{mynumber} points to \code{myfloat}, 
if a state variable was declared as \code{myfloat} there would only be one 
alias lookup while if it was declared as \code{mynumber} there be two. The canonical
form for all \code{float}, \code{myfloat}, and \code{mynumber} would all be 
\code{float}.  This is what \cycpp should record.  Templates need to recursively 
determine the template type name and the types of all template parameters.
Computing the canonical form of a type automatically is necessary to avoid an 
entire class of typographic errors by the archetype developers.  The investment
into this mini-type system by the kernel developers has already been repaid several 
times over.

Aside from the type system semantics, pass 2 represents a relatively straightforward
process of building up archetype information for later use. Pass 3 of \cycpp where 
code generation happens is the fist instance of later use.  Conceptually, 
pass 3 is a more complex process than pass 2 because it must implement 
all of the member functions in Listing \ref{req-api}. However, in practice the bodies 
of each of these member functions follows its own pattern with respect to the 
state variables. This makes implementing pass 3 significantly easier.

Much like pass 2, pass 3 is also a state machine. The class that implements it is 
called \code{CodeGenerator} and the filters that live on this class implement 
the corresponding code generation routines.  While the \code{CodeGenerator}  does 
reuse some meta-data accumulation filters, it largely relies on the results of 
pass 2 for archetype and state variable information.  The only data that cannot be 
reused and is recomputed is that which pertains to the scope of each line of C++ code.

Pass 3 necessarily must traverse all lines of the source code for the third time.
On this pass, the \code{CodeGenerator} will replace certain \code{#pragma cyclus}
directives with the generated implementations.  Pass 3 may act on the output of
\code{cpp}, the results of pass 1.  However, it is more common for this 
to act on the original source and header files.  This requires that the 
archetype developer write in mostly normative C++ and not abuse the C preprocessor.
However, doing so avoids double include errors and other downstream issues with 
compilation. The results of pass 3, therefore, are a new version of the archetype
source code that differs only in that it contains automatically implemented 
member functions.

Table \ref{pass3-filters} displays the filters that the \code{CodeGenerator} 
employs, in order of precedence.  There is some overlap between these filters
and those used with the \code{StateAccumulator}. This enables the efficient reuse
of filters between state machines.

\begin{table}
\label{pass3-filters}
\caption{\cyclus Preprocessor Pass 3 Filters, higher order filters have 
         lower execution precedence.}
\begin{tabular}[htb]{|p{0.05\linewidth}|p{0.33\linewidth}|p{0.6\linewidth}|}
\hline
\textbf{order} & \textbf{filter} & \textbf{description} \\
\hline
1  & \code{InitFromCopyFilter} & Implements code generation for copy-constructor-like 
                                 \code{InitFrom()} member function. This may be called
                                 with the 
                        \code{#pragma cyclus [def\|decl\|impl] initfromcopy [classname]}
                                 directive.\\
\hline
2  & \code{InitFromDbFilter} & Implements code generation for database constructor 
                               \code{InitFrom()} member function. This may be called
                               with the 
                        \code{#pragma cyclus [def\|decl\|impl] initfromdb [classname]}
                               directive.\\
\hline
3  & \code{InfileToDbFilter} & Implements code generation for the \code{InfileToDb()} 
                               member function that converts an input file into its 
                               database representation. This may be called with the 
                        \code{#pragma cyclus [def\|decl\|impl] infiletodb [classname]}
                               directive.\\
\hline
4  & \code{CloneFilter} & Implements code generation for the \code{Clone()} member
                          function that clones prototypes. This may be called
                          with the 
                        \code{#pragma cyclus [def\|decl\|impl] clone [classname]}
                          directive.\\
\hline
5  & \code{SchemaFilter} & Implements code generation for the \code{schema()} member
                           function that returns the \gls{RNG} schema of the archetype
                           for input file validation. This may be called with the 
                        \code{#pragma cyclus [def\|decl\|impl] schema [classname]}
                           directive.\\
\hline
6  & \code{AnnotationsFilter} & Implements code generation for the \code{annotations()} 
                                member function that returns the archetype metadata
                                that was compiled during \cycpp pass 2.
                                This may be called with the 
                        \code{#pragma cyclus [def\|decl\|impl] annotations [classname]}
                                directive.\\
\hline
7  & \code{InitInvFilter} & Implements code generation for the \code{InitInv()} 
                            member function that sets the initial resource inventories 
                            of the agent. This may be called with the 
                        \code{#pragma cyclus [def\|decl\|impl] initinv [classname]}
                            directive.\\
\hline
8  & \code{SnapshotInvFilter} & Implements code generation for the \code{SnapshotInv()} 
                                member function that writes inventories to the 
                                database. This may be called with the 
                        \code{#pragma cyclus [def\|decl\|impl] snapshotinv [classname]}
                                directive.\\
\hline
9  & \code{SnapshotFilter} & Implements code generation for the \code{Snapshot()} 
                             member function that writes state variables to the
                             database. This may be called with the 
                        \code{#pragma cyclus [def\|decl\|impl] snapshot [classname]}
                             directive.\\
\hline
10 & \code{ClassFilter} & Sets the current class name and scope.\\
\hline
11 & \code{AccessFilter} & Sets the current access control level, either 
                           \code{public}, \code{private}, or \code{protected}.\\
\hline
12 & \code{NamespaceAliasFilter} & Implements namespace aliasing in the current 
                                   scope.\\ 
\hline
13 & \code{NamespaceFilter} & Sets and reverts a new namepsace scope.\\ 
\hline
\end{tabular}
\end{table}

\begin{table}
\label{pass3-filters-2}
\caption{\cyclus Preprocessor Pass 3 Filters (part 2).}
\begin{tabular}[htb]{|p{0.05\linewidth}|p{0.33\linewidth}|p{0.6\linewidth}|}
\hline
\textbf{order} & \textbf{filter} & \textbf{description} \\
\hline
14 & \code{VarDecorationFilter} & Implements the \cycpp \code{#pragma cyclus var <dict>}
                                  directive for state variable annotations. The 
                                  \code{<dict>} is evaluated in the current 
                                  context and queued up to be applied to the 
                                  next state variable declaration.\\ 
\hline
15 & \code{VarDeclarationFilter} & State variable declaration. Applies the results 
                                   of the immediately prior \code{VarDecorationFilter}
                                   as the state variable annotations. Furthermore, 
                                   this filter parses out the name of the 
                                   state variable, its index with respect to other 
                                   state variables on this class, and resolves its
                                   C++ type into an unambiguous form.\\ 
\hline
16 & \code{LinemarkerFilter} & Interprets \code{cpp} linemarker directives in order
                               to produce more useful debugging information in 
                               \cycpp.\\ 
\hline
17 & \code{DefaultPragmaFilter} & Implements the default code generation directive,
                                  \code{#pragma cyclus [def\|decl\|impl]}. This 
                                  calls out to all of the other code generation
                                  filter to obtain member function implementations.\\
\hline
18 & \code{PragmaCyclusErrorFilter} & Throws errors if \code{#pragma cyclus} 
                                      directive is incorrectly implemented.
                                      This moves errors from happening at compile 
                                      or run time to \cycpp.\\
\hline
\end{tabular}
\end{table}

When all of the pieces of \cycpp are brought together, the benefits scale as the 
number of state variables times the number of code generated member functions 
(currently 9). This implies roughly an order of magnitude savings on the number of 
lines that an archetype developer must write per state variable. However, the 
exponential savings comes from the fact that the archetype developers do not need
to understand those extra lines that they do not have to write. Using \cycpp 
there is less to learn about the \cyclus interface, and even knowing the \cyclus
interface completely there is still almost ten times less to write. Consider 
again the \code{Reactor} example presented in Listing \ref{rx-eg}.  These twelve 
lines of code are transformed into 112 lines by \cycpp.  The results of \cycpp
on this simple reactor may be seen in Listing \ref{rx-eg-cycpp}. 

\begin{lstlisting}[caption={Simple Reactor Archetype After Preprocessing with \cycpp, 
                            line marker directives have been removed for space}, 
                   label=rx-eg-cycpp]
class Reactor : public cyclus::Facility {
 public:
  Reactor (cyclus::Context* ctx) {};
  virtual ~Reactor() {};

  virtual void InitFrom(Reactor* m) {
    flux = m->flux;
    power = m->power;
    shutdown = m->shutdown;
  };

  virtual void InitFrom(cyclus::QueryableBackend* b) {
    cyclus::QueryResult qr = b->Query("Info", NULL);
    flux = qr.GetVal<double>("flux");
    power = qr.GetVal<float>("power");
    shutdown = qr.GetVal<bool>("shutdown");
  };

  virtual void InfileToDb(cyclus::InfileTree* tree, cyclus::DbInit di) {
    tree = tree->SubTree("config/*");
    cyclus::InfileTree* sub;
    int i;
    int n;
    flux = cyclus::OptionalQuery<double>(tree, "flux", 4e+14);
    power = cyclus::OptionalQuery<float>(tree, "power", 1000);
    shutdown = cyclus::Query<bool>(tree, "shutdown");
    di.NewDatum("Info")
    ->AddVal("flux", flux)
    ->AddVal("power", power)
    ->AddVal("shutdown", shutdown)
    ->Record();
  };

  virtual cyclus::Agent* Clone() {
    Reactor* m = new Reactor(context());
    m->InitFrom(this);
    return m;
  };

  virtual std::string schema() {
    return ""
      "<interleave>\n"
      "<optional>\n"
      "    <element name=\"flux\">\n"
      "        <data type=\"double\" />\n"
      "    </element>\n"
      "</optional>\n"
      "<optional>\n"
      "    <element name=\"power\">\n"
      "        <data type=\"float\" />\n"
      "    </element>\n"
      "</optional>\n"
      "<element name=\"shutdown\">\n"
      "    <data type=\"boolean\" />\n"
      "</element>\n"
      "</interleave>\n"
      ;
  };

  virtual Json::Value annotations() {
    Json::Value root;
    Json::Reader reader;
    bool parsed_ok = reader.parse(
      "{\"name\":\"Reactor\",\"entity\":\"unknown\",\"parents\":[],"
      "\"all_parents\":[],\"vars\":{\"flux\":{\"default\":4000000"
      "00000000.0,\"units\":\"n/cm2/2\",\"type\":\"double\",\"inde"
      "x\":0},\"power\":{\"default\":1000,\"units\":\"MWe\",\"type\""
      ":\"float\",\"index\":1},\"shutdown\":{\"doc\":\"Are we "
      "operating?\",\"type\":\"bool\",\"index\":2}}}", root);
    if (!parsed_ok) {
      throw cyclus::ValueError("failed to parse annotations for Reactor.");
    }
    return root;
  };

  virtual void InitInv(cyclus::Inventories& inv) {
  };

  virtual cyclus::Inventories SnapshotInv() {
    cyclus::Inventories invs;
    return invs;
  };

  virtual void Snapshot(cyclus::DbInit di) {
    di.NewDatum("Info")
    ->AddVal("flux", flux)
    ->AddVal("power", power)
    ->AddVal("shutdown", shutdown)
    ->Record();
  };

 private:
  #pragma cyclus var {'default': 4e14, 'units': 'n/cm2/2'}
  double flux;

  #pragma cyclus var {'default': 1000, 'units': 'MWe'}
  float power;

  #pragma cyclus var {'doc': 'Are we operating?'}
  bool shutdown;
};
\end{lstlisting}

Of course, archetypes may be much more complex than the \code{Reactor} example.
This archetype does not participate in resource exchange, take advantage of 
the reflection features, use more advanced annotation features, or have more than 
a handful of state variables.  However, even here, the value of a code generating
preprocessor is readily apparent.

\subsection{Database Backends \& Types}

\Cyclus transparently supports a potentially limitless number of different database 
backends. Currently two reference backends exist: \gls{SQLite} \cite{owens2006definitive} 
and \gls{HDF5} \cite{folk2011overview}. These two represent relational and hierarchical 
databases respectively and have very different underlying design philosophies.
Future formats that could be supported are plain text 
\gls{CSV} files or \gls{JSON}.  Given the wide range of potential uses cases, \cyclus must be able 
to execute only based on the feature set that is common between these formats.
Features that are not available in a single format must either be provided by \cyclus 
itself or become optional in the backend interface.

The type system and reflection provided by \cycpp 
allow archetypes to represent themselves in the database. Though this 
reflection can be taken advantage of and used elsewhere, it was initially called for 
by the need to be able to restart a simulation. On the other hand, 
the database model extends well beyond the needs of the archetypes alone by 
serving as the fundamental on-disk representation for all \cyclus input and output.

\Cyclus databases follow these fundamental abstractions:
\begin{itemize}
    \item All data are stored in tables with named columns,
    \item Tables live in a flat hierarchy,
    \item Columns may have any type described by the \cyclus type system, and
    \item All tables must have a \code{SimId} column which uniquely and 
          universally identifies the simulation.
\end{itemize}
This means that common databases notions such as the shape of a column, raw arrays, or
queryability must be optional, left out, or implemented inside the backend itself.
Of these, queryability is the most important. If a database format or its backend lacks 
queryability (such as \gls{CSV}) then it is impossible to start or restart a 
\cyclus simulation from simply this backend.  Such a format may be used in 
conjunction with another queryable format. Both \gls{HDF5} and \gls{SQLite} are queryable.

The database backends are deeply tied to the \cyclus type system. Types in \cyclus
are represented by unique integers given in the \code{enum} called \code{DbTypes}
which map onto C++ types.
Simple types are represented by simple name, such as \code{float} becomes
\code{FLOAT} which is assigned to 2. Container types, such as \code{vector},
are more complex in that each template specification (\code{vector<int>}) has
its own type in the \cyclus type system.  Containers are further delineated by 
the distinction between fixed-length and \gls{VL} versions. Thus even the 
relatively simple C++ type \code{std::vector<int>} receives two entries in the 
\cyclus type system: \code{VECTOR_INT} and \code{VL_VECTOR_INT} which are given 
the identifiers 10 and 11 and represent fixed- and variable-length versions 
respectively.  Thus the number of types in the \cyclus type system is obtained as 
2 to the power of the \emph{rank} or the total number of variable length parameters, 
including nettings.
For example, the number of \cyclus types for \code{std::map<int, std::string>} is 
four (\code{MAP_INT_STRING}, \code{VL_MAP_INT_STRING}, \code{MAP_INT_VL_STRING}, 
\code{VL_MAP_INT_VL_STRING}) since both maps and strings may be variable length.
Table \ref{some-types} displays a sampling of types currently implemented in 
\cyclus.
Each backend determines which types it wishes to support, though this must extend 
to a relatively robust subset in order to be able to run even simple simulation.

\begin{table}
\label{some-types}
\caption{Sample \cyclus Types}
\centering
\begin{tabular}[htb]{|c|l|l|c|}
\hline
\textbf{id} & \textbf{name} & \textbf{C++ type} & \textbf{rank} \\
\hline
0 & \code{BOOL} & \code{bool} & 0 \\
1 & \code{INT} & \code{int} & 0 \\
2 & \code{FLOAT} & \code{float} & 0 \\
3 & \code{DOUBLE} & \code{double} & 0 \\
4 & \code{STRING} & \code{std::string} & 1 \\
5 & \code{VL_STRING} & \code{std::string} & 1 \\
6 & \code{BLOB} & \code{cyclus::Blob} & 0 \\
7 & \code{UUID} & \code{boost::uuids::uuid} & 0 \\
8 & \code{VECTOR_BOOL} & \code{std::vector<bool>} & 1 \\
9 & \code{VL_VECTOR_BOOL} & \code{std::vector<bool>} & 1 \\
10 & \code{VECTOR_INT} & \code{std::vector<int>} & 1 \\
11 & \code{VL_VECTOR_INT} & \code{std::vector<int>} & 1 \\
 & $\cdots$ & $\cdots$ & \\
32 & \code{SET_STRING} & \code{std::set<std::string>} & 2 \\
33 & \code{VL_SET_STRING} & \code{std::set<std::string>} & 2 \\
34 & \code{SET_VL_STRING} & \code{std::set<std::string>} & 2 \\
35 & \code{VL_SET_VL_STRING} & \code{std::set<std::string>} & 2 \\
 & $\cdots$ & $\cdots$ & \\
42 & \code{LIST_INT} & \code{std::list<int>} & 1 \\
43 & \code{VL_LIST_INT} & \code{std::list<int>} & 1 \\
 & $\cdots$ & $\cdots$ & \\
57 & \code{PAIR_INT_INT} & \code{std::pair<int, int>} & 0 \\
 & $\cdots$ & $\cdots$ & \\
104 & \code{MAP_STRING_STRING} & \code{std::map<std::string, std::string>} & 3 \\
105 & \code{VL_MAP_STRING_STRING} & \code{std::map<std::string, std::string>} & 3 \\
106 & \code{MAP_STRING_VL_STRING} & \code{std::map<std::string, std::string>} & 3 \\
107 & \code{VL_MAP_STRING_VL_STRING} & \code{std::map<std::string, std::string>} & 3 \\
 & $\cdots$ & $\cdots$ & \\
120 & \code{MAP_VL_STRING_STRING} & \code{std::map<std::string, std::string>} & 3 \\
121 & \code{VL_MAP_VL_STRING_STRING} & \code{std::map<std::string, std::string>} & 3 \\
122 & \code{MAP_VL_STRING_VL_STRING} & \code{std::map<std::string, std::string>} & 3 \\
123 & \code{VL_MAP_VL_STRING_VL_STRING} & \code{std::map<std::string, std::string>} & 3 \\
 & $\cdots$ & $\cdots$ & \\
\hline
\end{tabular}
\end{table}

A key database-enabling feature of the \cyclus type system is that 
the values of all types must be directly \emph{hashable} using a cryptographic hash.
The directness implies that pointer and reference types are not allowed. For most 
database backends, indirection is not a supported feature. For those backends which 
do support indirection, such as \gls{HDF5} and its linking mechanism, there is not a 
clear translation from indirection in memory to indirection on disk.  Thus several 
classes of errors are avoided entirely.  

Hashability serves a dual role with respect to the backends. The first is that 
it provides a mechanism for uniquely identifying all elements of a type, within 
reason. \Cyclus uses the standard \gls{SHA1} \cite{eastlake2001us} algorithm to compute 
hash values as 160-bit integer.  Thus for types with a fixed bit width less than 
160, such as \code{int} (typically 32-bits) or \code{double} (64-bits), every 
element is uniquely identifiable. For variable-length data types or very long types,
the probability of a hash collision is only $2^{-160}$, which is approximately 
equal to $10^{-48}$.  This is a astronomically small possibility, even over the 
course of billions of simulations.  Thus backends may use the hash to automatically
de-duplicate data and store every unique value only once.

The second purpose for hashing is that backends may implement the storage 
of variable-length types as a \emph{bidirectional hash map} using the 
\gls{SHA1} as a key.  This data structure is a particular kind of associative array where the values are 
uniquely determined from the keys \emph{and} the keys are unquietly determined from 
the values. Furthermore, in \cyclus, the keys of this data structure are simply the 
hashes themselves. This differs from a typical hash map (e.g. Python dictionaries) 
in that they only require that values may be determined from the keys and only the
keys mus be unique.  With a bidirectional hash map, knowing either the key or the value
will grant one the value of the key respectively.  The \gls{HDF5} backend takes advantage 
of this data structure to store variable-length data in a 5-dimensional sparse array.
The hash is chopped up into an array of five 32-bit unsigned integers that 
index into this array. Then the hash is stored in the table and used to lookup 
the value in the corresponding sparse array for that type.  This creates an efficient 
mechanism for storing vast amounts of potentially redundant variable-length data in 
a manner that mirrors the column storage for primitive types (\code{bool}, \code{int}, 
etc.). Since the hash is itself the index into a sparse array, the overhead from 
this lookup is minimal as compared with other parts of backend infrastructure.

Archetype developers may create their own custom tables in the database as well.
This is done through using the backend interface directly in the archetype. 
Data that are fully dependent parameters of the archetype are not appropriate 
as state variables. Those data should not be stored in this way.  Custom tables 
have the same restrictions as other parts of the database.  However, custom tables
have the additional restriction that they may not reuse the table names that 
\cyclus itself uses. Writing to such tables is considered reserved to only
the kernel. 
Table \ref{std-tabs} shows the standard tables written by \cyclus.
The kernel will also produce tables whose names are based on the 
archetype specification for representing the archetype on disk.  These tables
are distinct from custom tables mentioned above but are also reserved for the 
kernel alone. 

\begin{table}
\label{std-tabs}
\caption{Standard Tables Reserved by the \Cyclus Kernel, Columns given in order with 
names and types.}
\centering
\begin{tabular}[htb]{|llp{0.75\linewidth}|}
\hline
\textbf{name} & \textbf{type} & \textbf{description} \\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Resources Table:} 
This table encodes a heritage tree for all resources. 
Because resources 
are tracked as immutable objects, every time a resource is changed in the 
simulation (split, combined, transmuted, decayed, etc.), it gets a new entry in 
this table.If two resources are 
combined into a new one, then the new resource entry will have the identifiers of the 
other two in its ``Parent1'' and ``Parent2'' columns. 
It is interesting to note that the \code{Resources}
table does not encode any information about where a resource exists. This information 
can be inferred by corroborating resource identifiers with the \code{ResCreators} and 
\code{Transactions} tables.} \\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier \\
\code{ResourceId} & \code{INT} & The unique ID for this resource entry. \\
\code{ObjId} & \code{INT} & A resources object id (\code{obj_id}) as it existed 
                            during the simulation simulation.\\
\code{Type} & \code{VL_STRING} & One of ``Material'' or ``Product''. These two types 
                                 of resources have different internal state stored 
                                 in different tables. If the type is product, 
                                 then the internal state can be found in the 
                                 \code{Products} table. If it is material, 
                                 then it is in the \code{Compositions} table.\\
\code{TimeCreated} & \code{INT} & The simulation time step at which this resource 
                                  state came into existence.\\
\code{Quantity} & \code{DOUBLE} & Amount of the resource in ``kg'' for material 
                                  resources. Amount in terms of the specific quality 
                                  for product resources.\\
\code{Units} & \code{VL_STRING} & ``kg'' for all material resources, ``NONE'' for 
                                   product resources.\\
\code{QualId} & \code{INT} & Used to identify the corresponding internal-state 
                             entry (or entries) in the \code{Products} or 
                             \code{Compositions} table depending on the resource type.\\
\code{Parent1} & \code{INT} & If a resource was newly created, this is zero. If this 
                              resource came from another via is transmutation, 
                              combining, or splitting, or decay then this is the 
                              parent ResourceId.\\
\code{Parent2} & \code{INT} & If a resource was newly created, this is zero. If this 
                              resource came from another via transmutation, decay, 
                              or splitting, Parent2 is also zero. If the resource 
                              came from another via combining this is the second 
                              parent's ResourceId.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Compositions Table:}
A composition consists of one or more nuclides and their respective mass fractions. 
Each nuclide for a composition gets its own row and have the same \code{QualId}.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier \\
\code{QualId} & \code{INT} & Key to associate this composition with one or more 
                             entries in the \code{Resources} table.\\
\code{NucId} & \code{INT} & Nuclide identifier in zzzaaammmm form.\\
\code{MassFrac} & \code{DOUBLE} & Mass fraction for the nuclide in this composition.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Recipes Table:} Store composition names.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier \\
\code{Recipe} & \code{VL_STRING} & Recipe name as given in the input file.\\
\code{QualId} & \code{INT} & Key to identify the composition for this recipe in the 
                             \code{Compositions} table.\\
\hline
\end{tabular}
\end{table}


\begin{table}
\label{std-tabs-2}
\caption{Standard Tables Reserved by the \Cyclus Kernel (cont.)} 
\centering
\begin{tabular}[htb]{|llp{0.75\linewidth}|}
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Products Table}}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier \\
\code{QualId} & \code{INT} & Key to associate this quality with one or more entries 
                             in the \code{Resources} table.\\
\code{Quality} & \code{VL_STRING} & Describes a product's quality (e.g. ``bananas'', 
                                    ``KWh'', etc.).\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{ResCreators Table:} Every time an agent 
                                     creates a new resource from scratch, that event 
                                     is recorded in this table.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{ResourceId} & \code{INT} & ID of a resource that was created at some point in 
                                 the simulation.\\
\code{AgentId} & \code{INT} & ID of the agent that created the resource associated 
                              with the \code{ResourceId}.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{AgentEntry Table:} Each agent that enters 
                                     and participates in a simulation gets a row in 
                                     this table.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{AgentId} & \code{INT} & Every agent in a simulation gets its own, unique ID.\\
\code{Kind} & \code{VL_STRING} & One of ``Region'', ``Inst'', ``Facility'', 
                                 or ``Agent''.\\
\code{Spec} & \code{VL_STRING} & The single-string of the agent specification.\\
\code{Prototype} & \code{VL_STRING} & The prototype name, as defined in the input file, 
                                      that was used to create this agent.\\
\code{ParentId} & \code{INT} & The AgentId of this agent’s parent - the agent that 
                               built or created this agent.\\
\code{Lifetime} & \code{INT} & Number of time steps an agent is designed to operate 
                               over. -1 indicates an infinite lifetime. Note that 
                               depending on how agents use the lifetime parameter, 
                               this may be entirely unrelated to how long agents 
                               were actually operating in the simulation.\\
\code{EnterTime} & \code{INT} & The time step when the agent was built and entered 
                                the simulation.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{AgentExit Table:} Due to implementation 
                                     details in the \Cyclus kernel, this table is 
                                     separate from the \code{AgentEntry} table. 
                                     If this table does not exist, then no agents 
                                     were decommissioned in the simulation.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{AgentId} & \code{INT} & Key to the \code{AgentId} on the \code{AgentEntry} table.\\
\code{ExitTime} & \code{INT} & The time step when the agent was decommissioned and 
                               exited the simulation.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Transactions Table:} Every single resource 
                                     transfer between two agents is recorded as a row 
                                     in this table.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{TransactionId} & \code{INT} & A unique identifier for this resource transfer.\\
\code{SenderId} & \code{INT} & \code{AgentId} for the sending agent.\\
\code{ReceiverId} & \code{INT} & \code{AgentId} for the receiving agent.\\
\code{ResourceId} & \code{INT} & Key to the entry in the \code{Resources} table that 
                                 describes the transferred resource.\\
\code{Commodity} & \code{VL_STRING} & The commodity under which this transfer was 
                                      negotiated.\\
\code{Time} & \code{INT} & The time step at which the resource transfer took place.\\
\end{tabular}
\end{table}


\begin{table}
\label{std-tabs-3}
\caption{Standard Tables Reserved by the \Cyclus Kernel (cont.)} 
\centering
\begin{tabular}[htb]{|llp{0.65\linewidth}|}
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Info Table:} Each simulation gets a 
                                     single row in this table describing global 
                                     simulation parameters and \Cyclus dependency 
                                     version information.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{Handle} & \code{VL_STRING} & A custom user-specified value from the input 
                                   file allowing for convenient identification of 
                                   simulations in a database (because the simulation 
                                   uuid is not very memorable by mere mortals).\\
\code{InitialYear} & \code{INT} & The year in which time step zero occurs.\\
\code{InitialMonth} & \code{INT} & The month that time step zero represents.\\
\code{Duration} & \code{INT} & The length of the simulation in time steps. Note that it 
                               is possible a simulation to terminate early before 
                               running its entire duration - see the \code{Finish} 
                               table section.\\
\code{ParentSimId} & \code{UUID} &  The SimId for this simulation's parent. Zero if 
                                    this simulation has no parent.\\
\code{ParentType} & \code{VL_STRING} &  One of:
    \begin{enumerate}
        \item ``init'' for simulations that are not based on any other simulation.
        \item ``restart'' for simulations that were restarted another simulation's 
              snapshot.
        \item ``branch'' for simulations that were started from a perturbed state of 
              another simulation's snapshot.
    \end{enumerate}\\
\code{BranchTime} & \code{INT} & Zero if this was not a restarted or branched 
                                 simulation. Otherwise, the time step of the 
                                 \code{ParentSim} at which the restart or branch 
                                 occurred.\\
\code{CyclusVersion} & \code{VL_STRING} & Version of \Cyclus used to run this 
                                          simulation.\\
\code{CyclusVersionDescribe} & \code{VL_STRING} & Detailed \Cyclus version info 
                                                  (with commit hash).\\
\code{SqliteVersion} & \code{VL_STRING} & SQLite version information.\\
\code{Hdf5Version} & \code{VL_STRING} & HDF5 version information.\\
\code{BoostVersion} & \code{VL_STRING} & Boost version information.\\
\code{LibXML2Version} & \code{VL_STRING} & libxml2 version information.\\
\code{CoinCBCVersion} & \code{VL_STRING} & COIN version information.\\
\hline
\end{tabular}
\end{table}


\begin{table}
\label{std-tabs-4}
\caption{Standard Tables Reserved by the \Cyclus Kernel (cont.)} 
\centering
\begin{tabular}[htb]{|llp{0.75\linewidth}|}
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Finish Table:} Each simulation gets 
                                     one row in this table.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{EarlyTerm} & \code{BOOL} & True if the simulation terminated early and did 
                                 not complete normally. False otherwise.\\
\code{EndTime} & \code{INT} & The time step at which the simulation ended.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{InputFiles Table:} Stores the simulation 
                                     input.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{Data} & \code{BLOB} & A dump of the entire input file used for this simulation.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{DecomSchedule Table:} When agents are 
                                     scheduled to be decommissioned in the simulation, 
                                     the details are recorded in this table.  Note that 
                                     this table contains an entry for each scheduling 
                                     regardless of whether or not it actually occurred; 
                                     if a simulation ended before time reached the 
                                     scheduled time, the agent would not have been
                                     decommissioned.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{AgentId} & \code{INT} & ID of the agent that is to be decommissioned.\\
\code{SchedTime} & \code{INT} & The time step on which this decommissioning event was
                                created.\\
\code{DecomTime} & \code{INT} & The time step on which the agent was (or would have
                                been) decommissioned.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{BuildSchedule Table:} When agents are 
                                     scheduled to be built in the simulation, the 
                                     details are recorded in this table.  Note that 
                                     this table contains an entry for each scheduling 
                                     regardless of whether or not it actually occurred; 
                                     if a simulation ended before time reached the 
                                     scheduled time, the agent would not have been
                                     built.} \\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{ParentId} & \code{INT} & The id of the agent that will become this new agent's
                               parent.\\
\code{Prototype} & \code{VL_STRING} & The name of the agent prototype that will be 
                                      used to generate the new agent. This corresponds 
                                      to the prototypes defined in an input files.\\
\code{SchedTime} & \code{INT} & The time step on which this build event was created.\\
\code{BuildTime} & \code{INT} & The time step on which the agent was (or would have
                                been) built and deployed into the simulation.\\
\hline
\multicolumn{3}{|p{0.95\linewidth}|}{\textbf{Snapshots Table:} Every snapshot made 
                                     during the simulation gets an entry in this table. 
                                     All times in this table are candidates for 
                                     simulation restart and branching.}\\
& & \\
\code{SimId} & \code{UUID} & Simulation identifier. \\
\code{Time} & \code{INT} & The time step a snapshot was taken for this simulation.\\
\hline
\end{tabular}
\end{table}

Though the database backend implementation and the associated type system may be 
complex to implement, its usage and underbelly is mostly transparent to users and 
archetype developers alike. Even for complex template types, the \cyclus type system
allows archetypes to be as expressive as they need to be to fit the model. 

\subsection{JSON Annotations}

Archetype metadata annotation is an important part of \cyclus because it allows for 
reflection on the archetype classes. Well-defined metadata entries are 
described in Tables \ref{sv-anno} \& \ref{ag-anno}. 
Additionally though, archetype developers may supply 
any other information they wish and ascribe to it the semantics that they desire.
This is done simply by adding undefined keys to the \code{#pragma cyclus var} and
\code{#pragma cyclus note} \cycpp directives.
While this ensures that the metadata is robust to future changes and archetype developer
customization, the annotations have implications for the \cyclus and archetype 
implementations.

Allowing for unknown metadata keys with unknown types for each value implies that 
the metadata is \emph{unstructured} \cite{feldman2007text}. From a C++ implementation 
standpoint, this means that there is no class or struct that can be declared whose
member variables encompass all possible metadata without at least one of those
members being a pointer or reference. This is because determining the type 
of a blob of memory at runtime in C++ must use \code{void*}, \code{char*}, 
or other pointer indirection. Representing annotation in memory is thus 
necessarily more complex than a single metadata class.

\acrlong{JSON} and its derivatives are largely acknowledged as sufficiently expressive 
formats for unstructured data \cite{moniruzzaman2013nosql}. This is because the
\gls{JSON} primitives, which include integers, floats, strings, booleans, null, arrays, 
and objects (hash tables with string keys), are easily translatable into native
data structures in most modern programming languages such as Python and C++. 
Furthermore the \gls{JSON} syntax is concise and intuitive. \gls{XML} could have been used 
as an alternative format, but a schema and the translation to native data structures 
would have to be handled manually. \gls{YAML} \cite{ben2009yaml} or Python itself offer 
more likely  alternatives to \gls{JSON} but require a more sophisticated interpreters 
corresponding to their more powerful syntax. \gls{JSON} is enough and just enough.

However, \gls{JSON} is a metadata representation that is meant to reside on disk, 
not in memory. Translation from plain text \gls{JSON} to C++ data structures is 
performed via the JsonCpp software \cite{eltuhamy2014native}. This does the work 
of parsing \gls{JSON} code, implementing the \gls{JSON} type system, and translating back and
forth between \gls{JSON} types and C++ types as need. It provides as fully 
introspective 
container for arbitrary metadata called \code{Json::Value}. Thus, an instance of this 
class is precisely what the \code{annotations()} archetype member function returns.
Therefore, the entire metadata workflow is as follows:
\begin{enumerate}
    \item Archetype developer writes metadata using annotation directives as a
          Python dictionary with string keys.
    \item \cycpp parses, evaluates, and accumulates the annotations into a single 
          metadata dictionary per archetype during pass 2 of preprocessing.
    \item Pass 3 of \cycpp converts the metadata to a \gls{JSON} formatted string using 
          \gls{JSON} utilities in the Python standard library. This is used as the meat of
          code generated code for \code{annotations()} member function.
    \item From C++ when \code{annotation()} is called, the \gls{JSON} string is parsed 
          by JsonCpp and a new instance of \code{Json::Value} is returned that
          corresponds to the metadata.
\end{enumerate}
In this way \gls{JSON} is used as an exchange format between Python and C++, between 
archetype developer and user, and between compile time and run time.

\subsection{XML Validation}

A key benefit to the \Cyclus simulation infrastructure is the run time guarantee
of valid input files provided to both users and archetype developers. Developers
are guaranteed valid construction of archetypes within a simulation, and users
are notified immediately if a given input file is would have resulted in invalid
archetype construction. The processes required to provide such guarantees are
implemented using robust schema validation with \acrlong{XML} and \acrlong{RNG}.

For a given archetype, a developer defines the expected input structure in the
\code{schema()} function manually or via the \code{#pragma cyclus var}
preprocessor directive. Upon initiating a \Cyclus simulation (i.e., at run
time), a master schema is generated by combining the schema of all discovered
archetypes on a given computing system and inserting the collection into a
general \Cyclus schema. The general \Cyclus schema is used to define
simulation-level input as well as general entity input. For example, all
\code{cyclus::Facility} archetypes have input parameters common to the
\code{cyclus::Facility} entity, e.g., a name and a lifetime, and input
parameters specific to their archetype. Listing \ref{fac-schema} shows a snippet
of a generated \Cyclus master schema section pertaining to
\code{cyclus::Facility} entity input on a computing system on which archetypes
named \code{Reactor}, \code{Source}, and \code{Sink} were installed. Listing
\ref{rx-schema} shows the generated schema for the simple \code{Reactor}
archetype discussed in section \S \ref{subsec-ppgc}.

\lstset{language=XML}
\begin{lstlisting}[caption={Generated \Cyclus Facility Schema for a Computing System with 
      \code{Reactor}, \code{Source}, and \code{Sink} Archetypes Installed}, 
    label=fac-schema]
<oneOrMore>
  <element name="facility">
    <element name="name"> 
      <text/> 
    </element>
    <optional>
      <element name="lifetime"> 
        <data type="nonNegativeInteger"/> 
      </element>
    </optional>
    <element name="config">
      <choice>
        <ref name="Reactor"/ >
        <ref name="Source"/ >
        <ref name="Sink"/ >
      </choice>
    </element>
  </element>
</oneOrMore>
\end{lstlisting}

\lstset{language=XML}
\begin{lstlisting}[caption={Generated Simple Reactor Schema}, 
                   label=rx-schema]
<element name="Reactor">
  <interleave>
    <optional>
      <element name="flux">
        <data type="double" />
      </element>
    </optional>
    <optional>
      <element name="power">
        <data type="float" />
      </element>
    </optional>
    <element name="shutdown">
      <data type="boolean" />
    </element>
  </interleave>
</element>
\end{lstlisting}

After generating master \Cyclus schema, user input is then sent to an instance
of the \code{cyclus::RelaxNGValidator} class which utilizes the C++ libxml2
library to validate the provided input against the generated \gls{RNG} schema. If
input validation is successful, the defined simulation is then instantiated and
executed. A snippet of valid input for the \code{Reactor} is shown in Listing
\ref{valid-xml}. Note that because the \code{<optional>} tag is utilized in the
schema, not all parameters are required to be specified. Furthermore, default
values defined in the \code{Reactor} \code{#pragma cyclus var} annotations are
used for the unspecified parameters.

\lstset{language=XML}
\begin{lstlisting}[caption={A Valid Input Snippet for the Simple Reactor}, 
                   label=valid-xml]
<facility>
  <name>SomeReactor</name>
  <lifetime>600</lifetime>
  <config>
    <Reactor>
      <power>1150</power>
    </Reactor>
  </config>
</facility>
\end{lstlisting}

However, if the input is determined to be invalid, an error is raised without
beginning the simulation. Listing \ref{invalid-xml} shows a snippet of input for
the \code{Reactor} which is invalid because the \code{power} input parameter
type is not a \code{float}; \Cyclus fails immediately with the error message
shown in Listing \ref{lst-error}.

\lstset{language=XML}
\begin{lstlisting}[caption={An Invalid Input Snippet for the Simple Reactor}, 
                   label=invalid-xml]
<facility>
  <name>SomeReactor</name>
  <lifetime>600</lifetime>
  <config>
    <Reactor>
      <power>magic</power>
    </Reactor>
  </config>
</facility>
\end{lstlisting}

\lstset{language=bash}
\begin{lstlisting}[caption={A \Cyclus Error Message from the Invalid 
      Input in Listing \ref{invalid-xml}}, 
                   label=lst-error]
Entity: line 23: element capacity: Relax-NG validity error : Type double doesn't allow value 'magic'
Entity: line 23: element capacity: Relax-NG validity error : Error validating datatype double
Entity: line 23: element capacity: Relax-NG validity error : Element power failed to validate content
 ERROR(core  ):Document failed schema validation
\end{lstlisting}
